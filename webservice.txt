WebService

Java原生提供的JAX-WS(Java API XML WebService)

1.服务端

  - 创建接口
    SEI(Service Endpoint Interface) @WebService
    在接口方法上使用@WebResult(name = 'xxx')指定返回值名称
    在方法参数上使用@WebParam(name = 'xxx')指定参数名

  - 创建实现类
    SIB(Service Implementation Bean) @WebService(endpointInterface = "com.my.project.jaxws.IMyService")

  - 开启服务
    String address = "http://localhost:9000/myService";
    Endpoint.publish(address, new MyServiceImpl());

2.客户端

  - 代码示例
    URL wsdlLocation = new URL("http://localhost:9000/myService?wsdl");
    //从WSDL命名空间定义属性中确定: new QName(targetNamespace, name)
    QName serviceName = new QName("http://jaxws.project.my.com/", "MyServiceImplService");
    Service service = Service.create(wsdlLocation, serviceName);
    IMyService my = service.getPort(IMyService.class);

  - 使用JDK提供的wsimport命令生成客户端源代码
    -d 指定生成文件的目录
    -keep 指定生成源文件
    -verbose 输出详细信息
    -p 指定生成文件的包名, 不指定则使用wsdl中定义
    -Xnocompile 不编译生成的源码文件
    -最后指定wsdl地址
    wsimport -d . -p com.my.project.jaxws.wsimport -keep -verbose -Xnocompile http://localhost:9000/myService?wsdl

3.WSDL文件的组成

  - types 访问类型定义，对应到一个xsd文件，每个类型都会对应一个对象
    <types>
      <xsd:schema>
        <xsd:import namespace="http://jaxws.project.my.com/" schemaLocation="http://localhost:9000/myService?xsd=1"/>
      </xsd:schema>
    </types> 

  - message SOAP消息定义(Simple Object Access Protocol)
    <message name="add"><!-- 方法请求消息 -->
      <part name="parameters" element="tns:add"/>
    </message>
    <message name="addResponse"><!-- 方法返回消息 -->
      <part name="parameters" element="tns:addResponse"/>
    </message>
    <message name="minus"><!-- 方法请求消息 -->
      <part name="parameters" element="tns:minus"/>
    </message>
    <message name="minusResponse"><!-- 方法返回消息 -->
      <part name="parameters" element="tns:minusResponse"/>
    </message>

  - portType 指定服务接口

    <portType name="IMyService">
      <operation name="add"><!-- operation节点对应方法 -->
        <!-- input节点对应请求参数 -->
        <input wsam:Action="http://jaxws.project.my.com/IMyService/addRequest" message="tns:add"/>
        <!-- output节点对应返回值 -->
        <output wsam:Action="http://jaxws.project.my.com/IMyService/addResponse" message="tns:addResponse"/>
      </operation>
      <operation name="minus">
        <input wsam:Action="http://jaxws.project.my.com/IMyService/minusRequest" message="tns:minus"/>
        <output wsam:Action="http://jaxws.project.my.com/IMyService/minusResponse" message="tns:minusResponse"/>
      </operation>
    </portType>

  - banding 指定消息传输格式

    <binding name="MyServiceImplPortBinding" type="tns:IMyService">
      <!-- style可选值: document/rpc -->
      <soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/>
      <operation name="add">
        <soap:operation soapAction=""/>
        <input>
          <!-- use可选值: literal(以xml格式传输)/encode(RMI, SOAPMessage encode格式) -->
          <soap:body use="literal"/>
        </input>
        <output>
          <soap:body use="literal"/>
        </output>
      </operation>
      <operation name="minus">
        <soap:operation soapAction=""/>
        <input>
          <soap:body use="literal"/>
        </input>
        <output>
          <soap:body use="literal"/>
        </output>
      </operation>
    </binding>

  - service 指定服务基本信息

    <service name="MyServiceImplService">
      <port name="MyServiceImplPort" binding="tns:MyServiceImplPortBinding">
        <soap:address location="http://localhost:9000/myService"/>
      </port>
    </service>

4.WebService接口测试

  - 使用Eclipse执行webservice方法:
    - 切换到JavaEE视图
    - 在工具栏打开Web Services Explorer
    - 在右上解点击 WSDL Page 按钮
    - 输入WSDL地址开始测试WebService接口

  - 使用TCPMon工具: http://ws.apache.org/tcpmon/
    - 指定TCPMon监听端口: 9001
    - 设置TCPMon将监听端口数据转发到WebService对应的地址和商品: 9000
    - 添加Listener
    - 修改调用WebService的代码, 将address的端口改为TCPMon的监听端口
    - 即可在请求过程中截获WebService报文

5.服务类型:

  - 基于实体的服务(基本的数据发布)，如：查询用户基本信息
  - 基于功能的服务(基本功能的发布)，如：天气预报服务
  - 基于流程的服务(业务流程)，如：不同独立系统之间的业务流程

XML相关基础

1.DTD

  DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。它使用一系列的合法元素来定义文档结构
  DTD教程: http://w3school.com.cn/dtd/index.asp

  定义元素: <!ELEMENT 元素名称 类别>或者<!ELEMENT 元素名称 (元素内容)>
  定义属性: <!ATTLIST 元素名称 属性名称 属性类型 默认值>

  - 常用控制符:
    1. ?表示0次或1次
    2. *表示0次或多次
    3. +表示1次或者多次
    4. 默认表示1次
  
  - 属性类型:
    1. CDATA 值为字符数据
    2. (en1|en2|...) 此值是枚举列表中的一个值
    3. ID 值为唯一的id
    4. IDREF 值为另外一个元素的id
    5. IDREFS 值为其他id的列表
    6. NMTOKEN 值为合法的XML名称
    7. NMTOKENS 值为合法的XML名称列表
    8. ENTITY 值是一个实体
    9. ENTITIES 值是一个实体列表
    10.NOTATION 此值是符号的名称
    11.xml: 值是一个预定义的XML值
  
  - 默认值:
    1. 值 属性的默认值
    2. #REQUIRED 属性值是必须的
    3. #IMPLIED 属性不是必须的
    4. #FIXED value 属性值是固定的

2.Schema

  - DTD的问题

    1.元素命名冲突
    2.对XML格式的限制粒度不够细致
    3.专用的DTD语法

  - Schema的特点

    1.通过一种更合理的方式来编写XML的限制文件(基于XML语法)
    2.使用命名空间来支持多个名称相同的元素
    3.很好的完成对所有对象的修饰并且提供大量的数据类型

  - 命名空间

    <?xml version="1.0" encoding="UTF-8"?>
    <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.example.org/schema01"
        xmlns="http://www.example.org/schema01"
        elementFormDefault="qualified">
    </xs:schema>

    1.targetNamespace="http://www.example.org/schema01"
    此schema定义的元素的命名空间"http://www.example.org/schema01"

    2.xmlns:xs="http://www.w3.org/2001/XMLSchema"
    schema中用到的元素和数据类型来自命名空间
      "http://www.w3.org/2001/XMLSchema"
    并且这个命名空间的元素和数据类型应该使用前缀xs:
    注意: 这是默认需要引入的命名空间, 它包含了所有schema定义的元素和数据类型

    3.xmlns="http://www.example.org/schema01"
    默认命名空间是"http://www.example.org/schema01"
    注意: 这里的默认命名空间即是此schema本身的命名空间
    表示本文档定义的元素和数据类型在当前文档中可以直接引用

    4.elementFormDefault="qualified"
    任何XML实例文档所使用的且在此schema中声明过的元素必须被命名空间限定

  - 在XML中使用Schema进行格式限制

    <user xmlns="http://www.example.org/schema01"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.example.org/schema01 http://www.example.org/schema01">
        ...
    </user>

    1.xmlns="http://www.example.org/schema01"
    声明此XML文档的默认命名空间

    2.xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    声明XML Schema实例命名空间, 用于引入其他命名空间

    3.xsi:schemaLocation="http://www.example.org/schema01 http://www.example.org/schema01"
    schemaLocation属性有两个值:
    一、需要使用的命名空间
    二、供命名空间使用的XML schema的位置

    4.编写好的Schema可以添加到Eclipse的XML Catalog，使编辑器可以验证XML
    点击菜单栏: Preferences --> XML --> XML Catalog
    --> User Specified Entries --> Add --> Workspace --> 选择工作空间内的Schema文件

    5.可以在XML文档中直接引用本地Schema文件
    xsi:noNamespaceSchemaLocation="schema01.xsd"

  - Schema简易类型
    string/decimal/integer/boolean/date/time
    所有的属性均作为简易类型来声明

  - Schema Order指示器
    <all> 指示器规定子元素可以按照任意顺序出现, 且每个子元素必须只出现一次
    <choice> 指示器规定可出现某个子元素或者可出现另外一个子元素(非此即彼)
    <sequence> 规定子元素必须按照特定的顺序出现

  - 限定(restriction)用于为XML元素或者属性定义可接受的值
    对XML元素的限定被称为facet
    如: 定义了带有一个限定且名为age的元素, age的值不能低于0或者高于120
    <xs:element name="age">
      <xs:simpleType>
        <xs:restriction base="xs:integer">
          <xs:minInclusive value="0"/>
          <xs:maxInclusive value="120"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:element>

  - Schema编写方式
    Russian Doll(俄罗斯套娃式)
    - 只有一个根元素, 嵌套定义类型
    - 优点: 结构清晰
    - 缺点: 元素无法重用
    Salami Slice(腊肠切片式)
    - 将所有元素单独定义出来, 然后互相引用
    - 优点: 元素可以最大程度的重用
    - 缺点: 文档结构不清晰, 根结点不清晰
    Venetian Blind(百叶窗式)
    - 结合以上两种风格的定义方式
    - 推荐一个类对应一个schema(.xsd)文件

  - 使用JDK提供的xjc命令通过schema文件生成对应的Java类
    -d 指定生成文件的目录
    -p 指定生成文件的包名
	-encoding 指定生成源码的文件编码
    -verbose 输出详细信息
    -最后指定xsd文件的路径
    xjc -d src/main/java -p com.my.project.jaxws.xjc -encoding UTF-8 -verbose src/main/resources/schema/xjc/class.xsd

3.Java中处理XML的API

  - 使用JAXB对Java对象和XML进行互相转换
  - 使用Stax处理XML(遍历/查找/XPath/XMLStreamWriter/Transformer)

